package pattern

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern
*/
/*
	Использование:
	1) когда есть объект, поведение которого кардинально меняется в зависимости от внутреннего
	состояния, причем типов состояния много, и их код часто меняется
	2) когда код класса содержит множество больших, похожих друг на друга, условных операторов,
	которые выбирают поведения в зависимости от текущих значений полей класса 
	3) когда сознательно используют табличную машину состояний, построенную на условных операторах,
	но вынуждены мириться с дублированием кода для похожих состояний и переходов 

	+:
	1) избавляет от множества больших условных операторов машины состояний
	2) концентрирует в одном месте код, связанный с определенным состоянием
	3) упрощает код контекста

	-:
	1) может неоправданно усложнить код, если состояний мало и они редко меняются
*/
import "fmt"


type State interface {
	Handle()
}

type Context struct {
	State
}

func (c *Context) Request() {
	c.State.Handle()
}

func (c *Context) SetState(state State) {
	c.State = state
}

type StateA struct {}

func (s *StateA) Handle() {
	fmt.Println("StateA")	
}

type StateB struct {}

func (s *StateB) Handle() {
	fmt.Println("StateB")
}

